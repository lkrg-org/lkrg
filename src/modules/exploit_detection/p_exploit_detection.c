/*
 * pi3's Linux kernel Runtime Guard
 *
 * Component:
 *  - Exploit detection main module
 *
 * Notes:
 *  - None
 *
 * Timeline:
 *  - Created: 06.IX.2017
 *
 * Author:
 *  - Adam 'pi3' Zabrocki (http://pi3.com.pl)
 *
 */

#include "../../p_lkrg_main.h"

void p_dump_creds(struct p_cred *p_where, const struct cred *p_from) {

   /* Track process's capabilities */
   memcpy(&p_where->cap_inheritable, &p_from->cap_inheritable, sizeof(kernel_cap_t));
   memcpy(&p_where->cap_permitted, &p_from->cap_permitted, sizeof(kernel_cap_t));
   memcpy(&p_where->cap_effective, &p_from->cap_effective, sizeof(kernel_cap_t));
   memcpy(&p_where->cap_bset, &p_from->cap_bset, sizeof(kernel_cap_t));
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
   memcpy(&p_where->cap_ambient, &p_from->cap_ambient, sizeof(kernel_cap_t));
#endif

   /* Track process's IDs */
   p_set_uid(&p_where->uid, p_get_uid(&p_from->uid));
   p_set_gid(&p_where->gid, p_get_gid(&p_from->gid));
   p_set_uid(&p_where->suid, p_get_uid(&p_from->suid));
   p_set_gid(&p_where->sgid, p_get_gid(&p_from->sgid));
   p_set_uid(&p_where->euid, p_get_uid(&p_from->euid));
   p_set_gid(&p_where->egid, p_get_gid(&p_from->egid));
   p_set_uid(&p_where->fsuid, p_get_uid(&p_from->fsuid));
   p_set_gid(&p_where->fsgid, p_get_gid(&p_from->fsgid));

   /* Track process's securebits - TODO: research */
   p_where->securebits = p_from->securebits;

   /* Track process's critical pointers */
   p_where->user     = p_from->user;
   p_where->user_ns  = p_from->user_ns;

}

void p_update_ed_process(struct p_ed_process *p_source, struct task_struct *p_task) {

   /* Track process's metadata */
   p_source->p_ed_task.p_task            = p_task;
   p_source->p_ed_task.p_pid             = p_task->pid;
   p_source->p_ed_task.p_cred_ptr        = p_task->cred;
   p_source->p_ed_task.p_real_cred_ptr   = p_task->real_cred;
   p_dump_creds(&p_source->p_ed_task.p_cred, p_task->cred);
   p_dump_creds(&p_source->p_ed_task.p_real_cred, p_task->real_cred);
   strncpy(p_source->p_ed_task.p_comm, p_task->comm, TASK_COMM_LEN);
   p_source->p_ed_task.p_comm[TASK_COMM_LEN] = 0x0;

}

void p_set_ed_process_on(struct p_ed_process *p_source) {

   p_source->p_ed_task.p_off = 0x0;
   p_source->p_ed_task.p_off_count = 0x0;

}

void p_set_ed_process_off(struct p_ed_process *p_source) {

   p_source->p_ed_task.p_off = 0x1;

}

int p_print_task_f(void *p_arg) {

   struct task_struct *p_task = (struct task_struct *)p_arg;

   p_print_log(P_LKRG_CRIT,
                  "%s [%d]\n", p_task->comm, task_pid_nr(p_task));

   return P_LKRG_SUCCESS;
}

int p_dump_task_f(void *p_arg) {

   struct task_struct *p_task = (struct task_struct *)p_arg;
   int p_ret = P_LKRG_SUCCESS;
   struct p_ed_process *p_tmp;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_dump_task_f>\n");

   if ( (p_tmp = p_alloc_ed_pids()) == NULL) {
      p_print_log(P_LKRG_ERR,
             "p_alloc_ed_pids() returned NULL for pid %d :(\n",p_task->pid);
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_dump_task_f_out;
   }

   p_update_ed_process(p_tmp, p_task);
   p_set_ed_process_on(p_tmp);

   p_rb_init_ed_pid_node(&p_tmp->p_rb);
   if (p_rb_add_ed_pid(&p_global_ed_pids_root, p_task->pid, p_tmp)) {
      p_print_log(P_LKRG_INFO,
                   "pid => %d, is already inserted!\n",p_task->pid);
      p_free_ed_pids(p_tmp);
      p_ret = 0x1;
      goto p_dump_task_f_out;
   } else {
      p_print_log(P_LKRG_INFO,
                   "Inserting pid => %d\n", p_task->pid);
   }

p_dump_task_f_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_dump_task_f> (p_ret => %d)\n",p_ret);

   return p_ret;
}

int p_remove_task_pid_f(pid_t p_arg) {

   int p_ret = P_LKRG_SUCCESS;
   struct p_ed_process *p_tmp;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_remove_task_pid_f>\n");

   if ( (p_tmp = p_rb_find_ed_pid(&p_global_ed_pids_root, p_arg)) == NULL) {
      // This process is not on the list!
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_remove_task_pid_f_out;
   }

   p_rb_del_ed_pid(&p_global_ed_pids_root, p_tmp);
   p_print_log(P_LKRG_INFO, "Removing ED pid => %d\n", p_arg);

p_remove_task_pid_f_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_remove_task_pid_f> (p_ret => %d)\n",p_ret);

   return p_ret;
}

int p_iterate_processes(int (*p_func)(void *)) {

   int p_ret = P_LKRG_SUCCESS;
   struct task_struct *p_ptmp, *p_tmp;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_iterate_processes>\n");

   spin_lock(&p_rb_ed_pids_lock);
   rcu_read_lock();
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
   for_each_process_thread(p_ptmp, p_tmp) {
#else
   // tasklist_lock
   do_each_thread(p_ptmp, p_tmp) {
#endif
      /* do not touch kernel threads or the global init */
      if (p_tmp->flags & PF_KTHREAD || is_global_init(p_tmp))
         continue;

      task_lock(p_tmp);
      if ( (p_ret = p_func(p_tmp)) != 0) {
         p_print_log(P_LKRG_INFO,
                      "<Exploit Detection> Error[%d] during process[%d |%s] iteration!\n",
                                                           p_ret, task_pid_nr(p_tmp), p_tmp->comm);
      }
      task_unlock(p_tmp);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
   }
#else
   // tasklist_unlock
   } while_each_thread(p_ptmp, p_tmp);
#endif
   rcu_read_unlock();
   spin_unlock(&p_rb_ed_pids_lock);

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_iterate_processes> (p_ret => %d)\n",p_ret);

   return p_ret;
}

int p_cmp_creds(struct p_ed_process_task *p_task, struct task_struct *p_current, char p_opt) {

   int p_ret = 0x0;

   /* *UID */
   if (uid_gt(p_task->p_cred.uid, p_current->cred->uid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different UID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_uid(&p_task->p_cred.uid), p_get_uid(&p_current->cred->uid));
      }
      p_ret++;
   }

   if (uid_gt(p_task->p_cred.euid, p_current->cred->euid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different EUID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_uid(&p_task->p_cred.euid), p_get_uid(&p_current->cred->euid));
      }
      p_ret++;
   }

   if (uid_gt(p_task->p_cred.suid, p_current->cred->suid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different SUID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_uid(&p_task->p_cred.suid), p_get_uid(&p_current->cred->suid));
      }
      p_ret++;
   }

   if (uid_gt(p_task->p_cred.fsuid, p_current->cred->fsuid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different FSUID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_uid(&p_task->p_cred.fsuid), p_get_uid(&p_current->cred->fsuid));
      }
      p_ret++;
   }

   /* *GID */
   if (gid_gt(p_task->p_cred.gid, p_current->cred->gid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different GID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_gid(&p_task->p_cred.gid), p_get_gid(&p_current->cred->gid));
      }
      p_ret++;
   }

   if (gid_gt(p_task->p_cred.egid, p_current->cred->egid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different EGID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_gid(&p_task->p_cred.egid), p_get_gid(&p_current->cred->egid));
      }
      p_ret++;
   }

   if (gid_gt(p_task->p_cred.sgid, p_current->cred->sgid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different SGID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_gid(&p_task->p_cred.sgid), p_get_gid(&p_current->cred->sgid));
      }
      p_ret++;
   }

   if (gid_gt(p_task->p_cred.fsgid, p_current->cred->fsgid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different FSGID! [%d vs %d :(\n",
             task_pid_nr(p_current), p_current->comm, p_get_gid(&p_task->p_cred.fsgid), p_get_gid(&p_current->cred->fsgid));
      }
      p_ret++;
   }

   return p_ret;
}

int p_cmp_tasks(struct p_ed_process *p_orig, struct task_struct *p_current) {

   int p_ret = 0x0;

   if (p_orig->p_ed_task.p_task != p_current) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different 'task_struct\' pointer [0x%p vs 0x%p] :(\n",
                                    task_pid_nr(p_current), p_current->comm,p_orig->p_ed_task.p_task,p_current);
      p_ret++;
   }

   if (p_orig->p_ed_task.p_off) {
      p_orig->p_ed_task.p_off_count++;
      if (p_orig->p_ed_task.p_off_count > 6) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected data corruption attack! "
                                  "process[%d | %s] has been disabled form checking %d times! :(\n",
                                  task_pid_nr(p_current), p_current->comm, p_orig->p_ed_task.p_off_count);
         p_ret++;
      } else
         return 0x0;
   }

   if (p_orig->p_ed_task.p_cred_ptr != p_current->cred) {
      if (p_cmp_creds(&p_orig->p_ed_task, p_current, 0x0)) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected pointer swapping attack!"
                                  "process[%d | %s] has different 'cred\' pointer [0x%p vs 0x%p] :(\n",
                                  task_pid_nr(p_current), p_current->comm,p_orig->p_ed_task.p_cred_ptr,p_current->cred);
         p_ret++;
      }
   }

   if (p_orig->p_ed_task.p_real_cred_ptr != p_current->real_cred) {
      if (p_cmp_creds(&p_orig->p_ed_task, p_current, 0x0)) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected pointer swapping attack!"
                                  "process[%d | %s] has different 'real_cred\' pointer [0x%p vs 0x%p] :(\n",
                          task_pid_nr(p_current), p_current->comm,p_orig->p_ed_task.p_real_cred_ptr,p_current->real_cred);
         p_ret++;
      }
   }

   p_ret += p_cmp_creds(&p_orig->p_ed_task, p_current, 0x1);

   return p_ret;
}

int p_validate_task_f(void *p_arg) {

   int p_ret = P_LKRG_SUCCESS;
   struct p_ed_process *p_tmp;
   struct task_struct *p_task = (struct task_struct *)p_arg;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_validate_task_f>\n");

   if ( (p_tmp = p_rb_find_ed_pid(&p_global_ed_pids_root, task_pid_nr(p_task))) == NULL) {
      // This process is not on the list!
      if (p_task->state != TASK_DEAD) {
         p_ret = P_LKRG_GENERAL_ERROR;
         p_print_log(P_LKRG_INFO,
                  "<Exploit Detection> Can\'t find process[%d |%s] in internal tracking list!\n",
                                                                   task_pid_nr(p_task), p_task->comm);
      }
      goto p_validate_task_out;
   }

   rcu_read_lock();
   if (p_cmp_tasks(p_tmp, p_task)) {
      // kill this process!
      p_ed_kill_task_by_task(p_task);
   }
   rcu_read_unlock();

p_validate_task_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_validate_task_f> (p_ret => %d)\n",p_ret);

   return p_ret;
}

int p_exploit_detection_init(void) {

   int p_ret = P_LKRG_SUCCESS;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_exploit_detection_init>\n");

   if (p_init_rb_ed_pids()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t initialize ED pids cache and red-black tree :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }

   p_iterate_processes(p_dump_task_f);

   if (p_install_sys_execve_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook execve syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_do_fork_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook fork syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_do_exit_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook exit syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setreuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setreuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setresuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setresuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setfsuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setfsuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setgid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setgid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setregid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setregid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setresgid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setresgid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setfsgid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setfsgid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setgroups_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook setgroups syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_do_init_module_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook do_init_module function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_delete_module_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook delete_module syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_may_open_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can\'t hook may_open function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   goto p_exploit_detection_init_out;

p_exploit_detection_init_err:

   p_exploit_detection_exit();

p_exploit_detection_init_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_exploit_detection_init> (p_ret => %d)\n",p_ret);

   return p_ret;
}


void p_exploit_detection_exit(void) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_exploit_detection_exit>\n");

   p_uninstall_sys_execve_hook();
   p_uninstall_do_fork_hook();
   p_uninstall_do_exit_hook();
   p_uninstall_sys_setuid_hook();
   p_uninstall_sys_setreuid_hook();
   p_uninstall_sys_setresuid_hook();
   p_uninstall_sys_setfsuid_hook();
   p_uninstall_sys_setgid_hook();
   p_uninstall_sys_setregid_hook();
   p_uninstall_sys_setresgid_hook();
   p_uninstall_sys_setfsgid_hook();
   p_uninstall_sys_setgroups_hook();
   p_uninstall_do_init_module_hook();
   p_uninstall_sys_delete_module_hook();
   p_uninstall_may_open_hook();

   /* Before deleting cache i should clean each entry! */
   p_delete_rb_ed_pids();
   p_print_log(P_LKRG_INFO, "kmem_cache \"p_ed_pids\" destroyed!\n");

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_exploit_detection_exit>\n");
}
