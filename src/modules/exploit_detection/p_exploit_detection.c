/*
 * pi3's Linux kernel Runtime Guard
 *
 * Component:
 *  - Exploit detection main module
 *
 * Notes:
 *  - None
 *
 * Timeline:
 *  - Created: 06.IX.2017
 *
 * Author:
 *  - Adam 'pi3' Zabrocki (http://pi3.com.pl)
 *
 */

#include "../../p_lkrg_main.h"

struct p_ed_global_variables p_ed_guard_globals;
#ifdef CONFIG_SECURITY_SELINUX
int *p_selinux_enabled;
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
struct p_selinux_state *p_selinux_state;
#else
int *p_selinux_enforcing;
#endif
#endif
#endif
unsigned long p_global_off_cookie;
unsigned long p_global_cnt_cookie;
struct kmem_cache *p_ed_wq_valid_cache = NULL;
struct kmem_cache *p_ed_pcfi_cache = NULL;

#define p_ed_pcfi_alloc()      kmem_cache_alloc(p_ed_pcfi_cache, GFP_ATOMIC)
#define p_ed_pcfi_free(name)   kmem_cache_free(p_ed_pcfi_cache, (void *)(name))

int (*p_is_kernel_text_address)(unsigned long p_addr) = 0x0;
int (*p_freeze_processes)(void) = 0x0;
void (*p_thaw_processes)(void) = 0x0;

unsigned long p_global_SMEP = 0x0;

struct p_umh_whitelist p_umh_global[] = {

   { "/etc/acpi/events/RadioPower.sh", 0x0 },
   { "/etc/acpi/wireless-rtl-ac-dc-power.sh", 0x0 },
   { "/sbin/pnpbios", 0x0 },
   { "/usr/sbin/eppfpga", 0x0 },
   { "/sbin/critical_overtemp", 0x0 },
   { "/sbin/bridge-stp", 0x0 },
   { "/sbin/nfsd-recall-failed", 0x0 },
   { "/sbin/poweroff", 0x0 },
   { "/sbin/modprobe", 0x0 },
   { "/sbin/ocfs2_hb_ctl", 0x0 },
   { "/sbin/nfsdcltrack", 0x0 },
   { "/sbin/nfs_cache_getent", 0x0 },
   { "/sbin/v86d", 0x0 },
   { "/sbin/drbdadm", 0x0 },
   { "/sbin/hotplug", 0x0 },
   { "/sbin/tomoyo-init", 0x0 },
#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
 #ifdef ANDROID_BUILD
   { "/system/bin/unififw", 0x0 },
 #else
   { "/usr/sbin/unififw", 0x0 },
 #endif /* ANDROID_BUILD */
#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,18,0)
   { "/usr/lib/lustre/lnet_upcall", 0x0 },
   { "/usr/lib/lustre/lnet_debug_log_upcall", 0x0 },
#endif
#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
   { "/sbin/osd_login", 0x0 },
#endif
   { "/system/bin/start", 0x0 },
   { "/lib/systemd/systemd-cgroups-agent", 0x0 },
   { "/usr/lib/systemd/systemd-cgroups-agent", 0x0 },
   { "/usr/share/apport/apport", 0x0 }

};

static int p_check_if_file_exists(char *p_arg) {

   int p_ret = P_LKRG_SUCCESS;
   struct path p_path;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_check_if_file_exists>\n");

// DEBUG
   p_debug_log(P_LKRG_DBG,
          "Trying to resolve [%s]\n",p_arg);

   if ( (p_ret = kern_path(p_arg, LOOKUP_FOLLOW, &p_path)) != P_LKRG_SUCCESS) {
      p_print_log(P_LKRG_INFO,
             "[kern_path] Can't resolve filename: [%s]\n",p_arg);
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_check_if_file_exists_out;
   }

   path_put(&p_path);
//   p_ret = P_LKRG_SUCCESS;

p_check_if_file_exists_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_check_if_file_exists> (p_ret => %d)\n",p_ret);

   return p_ret;
}

static void p_ed_wq_valid_cache_zero(void *p_arg) {

   struct work_struct *p_struct = p_arg;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_wq_valid_cache_zero>\n");

   memset(p_struct, 0x0, sizeof(struct work_struct));

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_wq_valid_cache_zero>\n");

}

int p_ed_wq_valid_cache_init(void) {

   int p_ret = P_LKRG_SUCCESS;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_wq_valid_cache_init>\n");

   if ( (p_ed_wq_valid_cache = kmem_cache_create("p_ed_wq_valid_cache", sizeof(struct work_struct),
                                                 0x0, SLAB_HWCACHE_ALIGN, p_ed_wq_valid_cache_zero)) == NULL) {
      p_print_log(P_LKRG_ERR, "kmem_cache_create() for exploit detection validation error! :(\n");
      p_ret = -ENOMEM;
   }

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_wq_valid_cache_init> (p_ret => %d)\n",p_ret);

   return p_ret;
}

void p_ed_wq_valid_cache_delete(void) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_wq_valid_cache_delete>\n");

   flush_workqueue(system_unbound_wq);
   if (p_ed_wq_valid_cache) {
      kmem_cache_destroy(p_ed_wq_valid_cache);
      p_ed_wq_valid_cache = NULL;
   }


// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_wq_valid_cache_delete>\n");
}

void p_dump_creds(struct p_cred *p_where, const struct cred *p_from) {

   /* Track process's capabilities */
   memcpy(&p_where->cap_inheritable, &p_from->cap_inheritable, sizeof(kernel_cap_t));
   memcpy(&p_where->cap_permitted, &p_from->cap_permitted, sizeof(kernel_cap_t));
   memcpy(&p_where->cap_effective, &p_from->cap_effective, sizeof(kernel_cap_t));
   memcpy(&p_where->cap_bset, &p_from->cap_bset, sizeof(kernel_cap_t));
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
   memcpy(&p_where->cap_ambient, &p_from->cap_ambient, sizeof(kernel_cap_t));
#endif

   /* Track process's IDs */
   p_set_uid(&p_where->uid, p_get_uid(&p_from->uid));
   p_set_gid(&p_where->gid, p_get_gid(&p_from->gid));
   p_set_uid(&p_where->suid, p_get_uid(&p_from->suid));
   p_set_gid(&p_where->sgid, p_get_gid(&p_from->sgid));
   p_set_uid(&p_where->euid, p_get_uid(&p_from->euid));
   p_set_gid(&p_where->egid, p_get_gid(&p_from->egid));
   p_set_uid(&p_where->fsuid, p_get_uid(&p_from->fsuid));
   p_set_gid(&p_where->fsgid, p_get_gid(&p_from->fsgid));

   /* Track process's securebits - TODO: research */
   p_where->securebits = p_from->securebits;

   /* Track process's critical pointers */
   p_where->user     = p_from->user;
   p_where->user_ns  = p_from->user_ns;

}

void p_dump_seccomp(struct p_seccomp *p_sec, struct task_struct *p_task) {

   p_sec->sec.mode    = p_task->seccomp.mode;   // Mode
   p_sec->sec.filter  = p_task->seccomp.filter; // Filter
   if (test_tsk_thread_flag(p_task,TIF_SECCOMP))
      p_sec->flag = 0x1;
   else
      p_sec->flag = 0x0;
   p_sec->flag_sync_thread = 0x0;

}

void p_update_ed_process(struct p_ed_process *p_source, struct task_struct *p_task) {

   /* Track process's metadata */
   p_source->p_ed_task.p_task            = p_task;
   p_source->p_ed_task.p_pid             = p_task->pid;
   p_source->p_ed_task.p_cred_ptr        = p_task->cred;
   p_source->p_ed_task.p_real_cred_ptr   = p_task->real_cred;
   p_source->p_ed_task.p_stack           = p_task->stack;
   /* Creds */
   p_dump_creds(&p_source->p_ed_task.p_cred, p_task->cred);
   p_dump_creds(&p_source->p_ed_task.p_real_cred, p_task->real_cred);
   /* Seccomp */
   p_dump_seccomp(&p_source->p_ed_task.p_sec, p_task);
   /* Name */
   strncpy(p_source->p_ed_task.p_comm, p_task->comm, TASK_COMM_LEN);
   p_source->p_ed_task.p_comm[TASK_COMM_LEN] = 0x0;

}

inline void p_validate_off_flag(struct p_ed_process *p_source, long p_val) {

   if (p_val % p_global_cnt_cookie) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has corrupted 'off' flag => 0x%lx (normalization via 0x%lx)!\n",
             p_source->p_ed_task.p_pid, p_source->p_ed_task.p_comm,
             p_val, p_global_cnt_cookie);
      // kill this process!
      rcu_read_lock();
      p_ed_kill_task_by_task(p_source->p_ed_task.p_task);
      rcu_read_unlock();
   }
}

inline void p_ed_is_off_off(struct p_ed_process *p_source, long p_val) {

   if (p_val != p_global_cnt_cookie) {
      if (p_val) {
         p_print_log(P_LKRG_CRIT,
                "<Exploit Detection> ON process[%d | %s] has corrupted 'off' flag => 0x%lx (normalization via 0x%lx)!\n",
                p_source->p_ed_task.p_pid, p_source->p_ed_task.p_comm,
                p_val, p_global_cnt_cookie);

         // kill this process!
         rcu_read_lock();
         p_ed_kill_task_by_task(p_source->p_ed_task.p_task);
         rcu_read_unlock();
      }
   }
}

int p_verify_ovl_create_or_link(struct p_ed_process *p_source) {

   register unsigned long p_off = p_source->p_ed_task.p_off ^ p_global_off_cookie; // Decode

   p_validate_off_flag(p_source,p_off);   // Validate

   return ((p_off / p_global_cnt_cookie) == 0x2) ? 0x1 : 0x0;
}

void p_ed_is_off_off_wrap(struct p_ed_process *p_source) {

   register unsigned long p_off = p_source->p_ed_task.p_off ^ p_global_off_cookie; // Decode
   p_ed_is_off_off(p_source,p_off);
}

void p_set_ed_process_on(struct p_ed_process *p_source) {

   register unsigned long p_off = p_source->p_ed_task.p_off ^ p_global_off_cookie; // Decode

   p_validate_off_flag(p_source,p_off);   // Validate
   p_off -= p_global_cnt_cookie;          // normalize
   p_ed_is_off_off(p_source,p_off);       // Validate

   p_source->p_ed_task.p_off = p_off ^ p_global_off_cookie; // Encode
   if (p_off == p_global_cnt_cookie)
      p_source->p_ed_task.p_off_count = 0x0;
}

void p_set_ed_process_off(struct p_ed_process *p_source) {

   register unsigned long p_off = p_source->p_ed_task.p_off ^ p_global_off_cookie; // Decode

   p_validate_off_flag(p_source,p_off);   // Validate
   p_ed_is_off_off(p_source,p_off);       // Validate
   p_off += p_global_cnt_cookie;          // normalize

   p_source->p_ed_task.p_off = p_off ^ p_global_off_cookie;
}

void p_set_ed_process_override_on(struct p_ed_process *p_source) {

   register unsigned long p_off = p_source->p_ed_task.p_off ^ p_global_off_cookie; // Decode

   p_validate_off_flag(p_source,p_off);   // Validate
   p_off -= p_global_cnt_cookie;          // normalize

   p_source->p_ed_task.p_off = p_off ^ p_global_off_cookie; // Encode
   if (p_off == p_global_cnt_cookie)
      p_source->p_ed_task.p_off_count = 0x0;
}

void p_set_ed_process_override_off(struct p_ed_process *p_source) {

   register unsigned long p_off = p_source->p_ed_task.p_off ^ p_global_off_cookie; // Decode

   p_validate_off_flag(p_source,p_off);   // Validate
   p_off += p_global_cnt_cookie;          // normalize

   p_source->p_ed_task.p_off = p_off ^ p_global_off_cookie;
}

void p_reset_ed_flags(struct p_ed_process *p_source) {

   p_source->p_ed_task.p_off = p_global_cnt_cookie ^ p_global_off_cookie;
   p_source->p_ed_task.p_off_count = 0x0;

}

int p_print_task_f(void *p_arg) {

   struct task_struct *p_task = (struct task_struct *)p_arg;

   p_print_log(P_LKRG_CRIT,
                  "%s [%d]\n", p_task->comm, task_pid_nr(p_task));

   return P_LKRG_SUCCESS;
}

int p_dump_task_f(void *p_arg) {

   struct task_struct *p_task = (struct task_struct *)p_arg;
   int p_ret = P_LKRG_SUCCESS;
   struct p_ed_process *p_tmp;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_dump_task_f>\n");

   if ( (p_tmp = p_alloc_ed_pids()) == NULL) {
      p_print_log(P_LKRG_ERR,
             "p_alloc_ed_pids() returned NULL for pid %d :(\n",p_task->pid);
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_dump_task_f_out;
   }

   p_update_ed_process(p_tmp, p_task);
//   p_set_ed_process_on(p_tmp);
   p_tmp->p_ed_task.p_off = p_global_cnt_cookie ^ p_global_off_cookie;
   p_tmp->p_ed_task.p_off_count = 0x0;

   p_rb_init_ed_pid_node(&p_tmp->p_rb);
   if (p_rb_add_ed_pid(&p_global_ed_pids_root, p_task->pid, p_tmp)) {
      p_print_log(P_LKRG_INFO,
                   "pid => %d is already inserted!\n",p_task->pid);
      p_free_ed_pids(p_tmp);
      p_ret = 0x1;
      goto p_dump_task_f_out;
   } else {
      p_print_log(P_LKRG_INFO,
                   "Inserting pid => %d\n", p_task->pid);
   }

p_dump_task_f_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_dump_task_f> (p_ret => %d)\n",p_ret);

   return p_ret;
}

int p_remove_task_pid_f(pid_t p_arg) {

   int p_ret = P_LKRG_SUCCESS;
   struct p_ed_process *p_tmp;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_remove_task_pid_f>\n");

   if ( (p_tmp = p_rb_find_ed_pid(&p_global_ed_pids_root, p_arg)) == NULL) {
      // This process is not on the list!
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_remove_task_pid_f_out;
   }

   p_rb_del_ed_pid(&p_global_ed_pids_root, p_tmp);
   p_print_log(P_LKRG_INFO, "Removing ED pid => %d\n", p_arg);

p_remove_task_pid_f_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_remove_task_pid_f> (p_ret => %d)\n",p_ret);

   return p_ret;
}

void p_iterate_processes(int (*p_func)(void *)) {

   int p_ret;
   struct task_struct *p_ptmp, *p_tmp;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_iterate_processes>\n");

   spin_lock(&p_rb_ed_pids_lock);
   rcu_read_lock();
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
   for_each_process_thread(p_ptmp, p_tmp) {
#else
   // tasklist_lock
   do_each_thread(p_ptmp, p_tmp) {
#endif
      /* do not touch kernel threads or the global init */
      if (p_tmp->flags & PF_KTHREAD || is_global_init(p_tmp))
         continue;

      if (p_tmp != current) {
         task_lock(p_tmp);
         if ( (p_ret = p_func(p_tmp)) != 0) {
            p_print_log(P_LKRG_INFO,
                         "<Exploit Detection> Error[%d] during process[%d |%s] iteration!\n",
                                                              p_ret, task_pid_nr(p_tmp), p_tmp->comm);
         }
         task_unlock(p_tmp);
      } else {
         if ( (p_ret = p_func(p_tmp)) != 0) {
            p_print_log(P_LKRG_INFO,
                         "<Exploit Detection> Error[%d] during process[%d |%s] iteration!\n",
                                                              p_ret, task_pid_nr(p_tmp), p_tmp->comm);
         }
      }
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
   }
#else
   // tasklist_unlock
   } while_each_thread(p_ptmp, p_tmp);
#endif
   rcu_read_unlock();
   spin_unlock(&p_rb_ed_pids_lock);

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_iterate_processes>\n");
}

int p_cmp_creds(struct p_ed_process_task *p_task, struct task_struct *p_current, char p_opt) {

   int p_ret = 0x0;

   /* *UID */
   if (uid_gt(p_task->p_cred.uid, p_current->cred->uid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different UID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_uid(&p_task->p_cred.uid), p_get_uid(&p_current->cred->uid));
      }
      p_ret++;
   }

   if (uid_gt(p_task->p_cred.euid, p_current->cred->euid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different EUID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_uid(&p_task->p_cred.euid), p_get_uid(&p_current->cred->euid));
      }
      p_ret++;
   }

   if (uid_gt(p_task->p_cred.suid, p_current->cred->suid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different SUID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_uid(&p_task->p_cred.suid), p_get_uid(&p_current->cred->suid));
      }
      p_ret++;
   }

   if (uid_gt(p_task->p_cred.fsuid, p_current->cred->fsuid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different FSUID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_uid(&p_task->p_cred.fsuid), p_get_uid(&p_current->cred->fsuid));
      }
      p_ret++;
   }

   /* *GID */
   if (gid_gt(p_task->p_cred.gid, p_current->cred->gid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different GID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_gid(&p_task->p_cred.gid), p_get_gid(&p_current->cred->gid));
      }
      p_ret++;
   }

   if (gid_gt(p_task->p_cred.egid, p_current->cred->egid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different EGID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_gid(&p_task->p_cred.egid), p_get_gid(&p_current->cred->egid));
      }
      p_ret++;
   }

   if (gid_gt(p_task->p_cred.sgid, p_current->cred->sgid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different SGID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_gid(&p_task->p_cred.sgid), p_get_gid(&p_current->cred->sgid));
      }
      p_ret++;
   }

   if (gid_gt(p_task->p_cred.fsgid, p_current->cred->fsgid)) {
      if (p_opt) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process[%d | %s] has different FSGID! %d vs %d\n",
             task_pid_nr(p_current), p_current->comm,
             p_get_gid(&p_task->p_cred.fsgid), p_get_gid(&p_current->cred->fsgid));
      }
      p_ret++;
   }

   return p_ret;
}

int p_cmp_tasks(struct p_ed_process *p_orig, struct task_struct *p_current) {

   int p_ret = 0x0;
   char *p_sec_strings[3] = { "SECCOMP_MODE_DISABLED", "SECCOMP_MODE_STRICT", "SECCOMP_MODE_FILTER" };
   register long p_off = p_orig->p_ed_task.p_off ^ p_global_off_cookie;


   if (p_off - p_global_cnt_cookie) {
      p_validate_off_flag(p_orig,p_off);   // Validate

      p_orig->p_ed_task.p_off_count++;

      if (p_orig->p_ed_task.p_off_count > P_ED_PROCESS_OFF_MAX) {
         p_print_log(P_LKRG_WARN,
                "PID:%d [%s] p_off[0x%lx] / p_global_cnt[0x%lx] -> %ld | p_off_count[%u]\n",
                p_orig->p_ed_task.p_pid,
                p_orig->p_ed_task.p_comm,
                p_off, p_global_cnt_cookie,
                p_off/p_global_cnt_cookie,
                p_orig->p_ed_task.p_off_count);
         /* That's is weird and it might be a potentially compromised process. Enforce validation now! */
/*
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected data corruption attack! "
                                  "process[%d | %s] has been disabled form checking %d times!\n",
                                  task_pid_nr(p_current), p_current->comm,
                                  p_orig->p_ed_task.p_off_count);
*/
//         p_ret++;
      }
      return 0x0;
   }


   if (p_orig->p_ed_task.p_task != p_current) {
      /*
       * On heavily loaded SMP machines, in a very rare corner case situation,
       * it is possible to hit an annoying kretprobe glitch.
       * If you are one of the "lucky" guys who hit this problem for one of the processes
       * being monitored by the Exploit Detection (ED) feature, you are a good candidate
       * to hit another problem. If at some point kernel decided to reuse already unused
       * pid (from the process which was affected by the glitching scenario) you are an even
       * better candidate to hit a potential little race condition in a function return
       * from do_fork().
       * When p_do_fork_ret() is invoked it tries to get a spin_lock for internal ED database
       * (which is red-black tree identified by p_rb_ed_pids_lock lock). If another CPU/core is
       * executing ED validation routine p_ed_enforce_validation() it might be faster to get
       * this lock before p_do_fork_ret() does (race condition). In that case, p_do_fork_ret()
       * does a busy wait, and the other CPU does verification. If you are the most "lucky" guy
       * who hit the glitching problem and pid reuse scenario for the process which supposed to
       * do attributes update for ED database from the p_do_fork_ret() function you will generate
       * a one-time FP. As soon as FP happens and verification routine unlocks the ED database,
       * p_do_fork_ret() kicks-in and fixes attributes, and FP will never happen again.
       * This is a very rare corner-case situation which can only be possible if you meet all
       * the problems together affecting exactly the same process (kretprobe glitch + pid reuse
       * + race condition on a heavily loaded SMP machine). It is possible to mitigate this
       * problem and we do it here.
       */
      p_print_log(P_LKRG_WARN,
             "<Exploit Detection> Potential kretprobe glitch detected for "
             "process[0x%p | %d | %s] vs orig[0x%p | %d | %s]\n",
             p_current,
             task_pid_nr(p_current),
             p_current->comm,
             p_orig->p_ed_task.p_task,
             p_orig->p_ed_task.p_pid,
             p_orig->p_ed_task.p_comm);
      return 0x0;
   }

   /* Validate stack first */
   if (p_ed_pcfi_validate_sp(p_current,p_orig,p_current->thread.sp)) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected stack pointer corruption (ROP?) - pCFI violation: process[%s | %d] !!!\n",
             p_current->comm,task_pid_nr(p_current));
      // kill this process! Another signal will be sent again from the caller function - it's OK.
      p_ed_kill_task_by_task(p_current);
      p_ret++;
   }

   if (p_orig->p_ed_task.p_cred_ptr != p_current->cred) {
      if (p_cmp_creds(&p_orig->p_ed_task, p_current, 0x0)) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected pointer swapping attack!"
                                  "process[%d | %s] has different 'cred' pointer [0x%p vs 0x%p]\n",
                                  task_pid_nr(p_current), p_current->comm,
                                  p_orig->p_ed_task.p_cred_ptr, p_current->cred);
         p_ret++;
      }
   }

   if (p_orig->p_ed_task.p_real_cred_ptr != p_current->real_cred) {
      if (p_cmp_creds(&p_orig->p_ed_task, p_current, 0x0)) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected pointer swapping attack!"
                                  "process[%d | %s] has different 'real_cred' pointer [0x%p vs 0x%p]\n",
                                  task_pid_nr(p_current), p_current->comm,
                                  p_orig->p_ed_task.p_real_cred_ptr, p_current->real_cred);
         p_ret++;
      }
   }

   p_ret += p_cmp_creds(&p_orig->p_ed_task, p_current, 0x1);

   /* Seccomp */
   if (p_orig->p_ed_task.p_sec.flag) { // SECCOMP was enabled so it make sense to compare...
      if (test_tsk_thread_flag(p_current,TIF_SECCOMP) != p_orig->p_ed_task.p_sec.flag) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected SECCOMP corruption!"
                                  "process[%d | %s] has corrupted TIF_SECCOMP flag! [%d vs %d]\n",
                                  task_pid_nr(p_current), p_current->comm,
                                  p_orig->p_ed_task.p_sec.flag, test_tsk_thread_flag(p_current,TIF_SECCOMP));
         p_ret++;
      }

      if (p_orig->p_ed_task.p_sec.sec.mode != p_current->seccomp.mode) {
         if (p_current->seccomp.mode < 0 || p_current->seccomp.mode > 2
             || p_orig->p_ed_task.p_sec.sec.mode < 0 || p_orig->p_ed_task.p_sec.sec.mode > 2) {
            p_print_log(P_LKRG_CRIT,
                "<Exploit Detection> Detected SECCOMP corruption!"
                                     "process[%d | %s] has UNKNOWN different SECCOMP mode! [%d vs %d]\n",
                                     task_pid_nr(p_current), p_current->comm,
                                     p_orig->p_ed_task.p_sec.sec.mode, p_current->seccomp.mode);
         } else {
            p_print_log(P_LKRG_CRIT,
                "<Exploit Detection> Detected SECCOMP corruption!"
                                     "process[%d | %s] has different SECCOMP mode! [%s vs %s]\n",
                                     task_pid_nr(p_current), p_current->comm,
                                     p_sec_strings[p_orig->p_ed_task.p_sec.sec.mode],
                                     p_sec_strings[p_current->seccomp.mode]);
         }
         p_ret++;
      }

      if (p_orig->p_ed_task.p_sec.sec.filter != p_current->seccomp.filter) {
         p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected SECCOMP corruption!"
                                  "process[%d | %s] has different SECCOMP filter pointer! [0x%p vs 0x%p]\n",
                                  task_pid_nr(p_current), p_current->comm,
                                  p_orig->p_ed_task.p_sec.sec.filter, p_current->seccomp.filter);
         p_ret++;
      }
   }

   return p_ret;
}

int p_validate_task_f(void *p_arg) {

   int p_ret = P_LKRG_SUCCESS;
   struct p_ed_process *p_tmp;
   struct task_struct *p_task = (struct task_struct *)p_arg;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_validate_task_f>\n");

   if ( (p_tmp = p_rb_find_ed_pid(&p_global_ed_pids_root, task_pid_nr(p_task))) == NULL) {
      // This process is not on the list!
      if (p_task->state != TASK_DEAD) {
         p_ret = P_LKRG_GENERAL_ERROR;
         p_print_log(P_LKRG_INFO,
                  "<Exploit Detection> Can't find process[%d |%s] in internal tracking list!\n",
                                                                   task_pid_nr(p_task), p_task->comm);
      }
      goto p_validate_task_out;
   }

   rcu_read_lock();
   if (p_cmp_tasks(p_tmp, p_task)) {
      // kill this process!
      p_ed_kill_task_by_task(p_task);
   }
   rcu_read_unlock();

p_validate_task_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_validate_task_f> (p_ret => %d)\n",p_ret);

   return p_ret;
}

#ifdef CONFIG_SECURITY_SELINUX
void p_validate_selinux(void) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_validate_selinux>\n");

   mutex_lock(&p_ed_guard_globals.p_selinux_lock);
   if (p_ed_guard_globals.p_selinux.p_selinux_enabled != *p_selinux_enabled) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected data corruption against SELINUX! 'selinux_enabled' has "
                                  "different value [%d vs %d] than expected. Original value will be restored!\n",
                                  *p_selinux_enabled,p_ed_guard_globals.p_selinux.p_selinux_enabled);
      *p_selinux_enabled = p_ed_guard_globals.p_selinux.p_selinux_enabled;
   }

#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
   if (p_ed_guard_globals.p_selinux.p_selinux_state.enforcing != p_selinux_state->enforcing) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected data corruption against SELINUX! 'selinux_state->enforcing' has "
                                  "different value [%d vs %d] than expected. Original value will be restored!\n",
                                  p_selinux_state->enforcing,p_ed_guard_globals.p_selinux.p_selinux_state.enforcing);
      p_selinux_state->enforcing = p_ed_guard_globals.p_selinux.p_selinux_state.enforcing;
   }
 #else
   if (p_ed_guard_globals.p_selinux.p_selinux_enforcing != *p_selinux_enforcing) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Detected data corruption against SELINUX! 'selinux_enforcing' has "
                                  "different value [%d vs %d] than expected. Original value will be restored!\n",
                                  *p_selinux_enforcing,p_ed_guard_globals.p_selinux.p_selinux_enforcing);
      *p_selinux_enforcing = p_ed_guard_globals.p_selinux.p_selinux_enforcing;
   }
 #endif
#endif
   mutex_unlock(&p_ed_guard_globals.p_selinux_lock);

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_validate_selinux>\n");
}
#endif

void p_ed_wq_valid_work(struct work_struct *p_work) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_wq_valid_work>\n");

#ifdef CONFIG_SECURITY_SELINUX
   // SELinux
   p_validate_selinux();
#endif

   /* Free the worker struct */
   if (p_work) {
      p_ed_free_valid(p_work);
   }

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_wq_valid_work>\n");
}

void p_ed_validate_globals(void) {

   struct work_struct *p_worker;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_validate_globals>\n");

   /* Validate globals... */
   // ...

   /* Prepare for validation which requires 'sleeping' */
   while ( (p_worker = p_ed_alloc_valid()) == NULL); // Should never be NULL
   INIT_WORK(p_worker, p_ed_wq_valid_work);
   /* schedule for execution */
   queue_work(system_unbound_wq, p_worker);


// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_wq_valid_work>\n");
}

void p_ed_enforce_validation(void) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_enforce_validation>\n");

   /* pCFI - validate SMEP and WP */
   if (p_global_SMEP)
      p_ed_pcfi_x86_validate_smep(0);
   p_ed_pcfi_x86_validate_wp(0);

   /* Validate processes and threads */
   p_iterate_processes(p_validate_task_f);

   /* Validate critical globals */
   p_ed_validate_globals();

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_enforce_validation>\n");
}

static void p_ed_pcfi_cache_zero(void *p_arg) {

   unsigned long *p_page = p_arg;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_pcfi_cache_zero>\n");

   memset(p_page, 0x0, P_PCFI_STACK_BUF);

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_pcfi_cache_zero>\n");

}

int p_ed_pcfi_cache_init(void) {

   int p_ret = P_LKRG_SUCCESS;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_pcfi_cache_init>\n");

   if ( (p_ed_pcfi_cache = kmem_cache_create("p_ed_pcfi_cache", P_PCFI_STACK_BUF,
                                            0x0, SLAB_HWCACHE_ALIGN, p_ed_pcfi_cache_zero)) == NULL) {
      p_print_log(P_LKRG_ERR, "kmem_cache_create() for exploit detection pCFI error! :(\n");
      p_ret = -ENOMEM;
   }

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_pcfi_cache_init> (p_ret => %d)\n",p_ret);

   return p_ret;
}

void p_ed_pcfi_cache_delete(void) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_pcfi_cache_delete>\n");

   if (p_ed_pcfi_cache) {
      kmem_cache_destroy(p_ed_pcfi_cache);
      p_ed_pcfi_cache = NULL;
   }

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_pcfi_cache_delete>\n");
}

static inline int p_is_obj_on_stack(struct task_struct *p_task, const void *p_addr) {

   void *p_stack = p_task->stack; //task_stack_page(p_task);

   return (p_addr >= p_stack) && (p_addr < (p_stack + THREAD_SIZE));
}

int p_ed_enforce_pcfi(struct task_struct *p_task, struct p_ed_process *p_orig, struct pt_regs *p_regs) {

   unsigned int i;
   unsigned long p_flags;
   struct stack_trace p_trace;
   const void *p_fp = (const void *)p_regs->bp;
   struct stack_frame p_frame;
   char p_not_valid = 0x0;
   unsigned int p_offset = 1;
   char p_sym1[KSYM_SYMBOL_LEN];

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_enforce_pcfi>\n");

   if (p_ed_pcfi_validate_sp(p_task,p_orig,p_regs->sp)) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Stack pointer corruption (ROP?) - pCFI violation: process[%s | %d] !!!\n",
             p_task->comm,task_pid_nr(p_task));
      // kill this process!
      p_ed_kill_task_by_task(p_task);
      p_not_valid = 0x1;
      goto p_ed_enforce_pcfi_out;
   }

   if (p_orig) {
      if (p_task != p_orig->p_ed_task.p_task) {
         p_print_log(P_LKRG_WARN,
                "<Exploit Detection> [pCFI] Potential kretprobe glitch detected for "
                "process[0x%p | %d | %s] vs orig[0x%p | %d | %s]\n",
                p_task,
                task_pid_nr(p_task),
                p_task->comm,
                p_orig->p_ed_task.p_task,
                p_orig->p_ed_task.p_pid,
                p_orig->p_ed_task.p_comm);
         goto p_ed_enforce_pcfi_out;
      }
   }

   if (!p_is_obj_on_stack(p_task, p_fp)) {
      p_debug_log(P_LKRG_WARN,
                  "Frame pointer is NOT on the stack - CFI is not enforced :(\n");
      goto p_ed_enforce_pcfi_out;
   }

   while ( (p_trace.entries = p_ed_pcfi_alloc()) == NULL); // Should never be NULL

   local_irq_save(p_flags);

   p_trace.max_entries = P_PCFI_STACK_BUF/sizeof(p_trace.entries[0]);
   p_trace.nr_entries = 0;

   if (p_trace.nr_entries < p_trace.max_entries)
      p_trace.entries[p_trace.nr_entries++] = p_regs->ip;

   while (p_trace.nr_entries < p_trace.max_entries) {
      p_frame.next_frame = NULL;
      p_frame.return_address = 0;

      if ((unsigned long)p_fp < p_regs->sp || !p_is_obj_on_stack(p_task, p_fp))
         break;

      memcpy(&p_frame, p_fp, sizeof(struct stack_frame));
      if (p_frame.return_address) {
         p_trace.entries[p_trace.nr_entries++] = p_frame.return_address;
      }

      if (p_fp == p_frame.next_frame)
         break;

      p_fp = p_frame.next_frame;
    }

//p_not_valid = 0x0;
   for (i = 0; i < p_trace.nr_entries-p_offset; i++) {
      if (!p_is_kernel_text_address(p_trace.entries[i])) {
         if (p_trace.nr_entries-p_offset > 4 && i > 4) {
            memset(p_sym1,0x0,KSYM_SYMBOL_LEN);
            sprint_symbol_no_offset(p_sym1,p_trace.entries[i-1]);
            if (!strncmp(p_sym1,"ret_from_fork",0xd)) {
               memset(p_sym1,0x0,KSYM_SYMBOL_LEN);
               sprint_symbol_no_offset(p_sym1,p_trace.entries[i-2]);
               if (!strncmp(p_sym1,"kthread",0x7)) {
                  continue;
               } else {
                  p_not_valid = 0x1;
                  break;
               }
            }
            p_not_valid = 0x1;
            break;
         } else {
            p_not_valid = 0x1;
            break;
         }
      }
   }

   if (p_not_valid) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Not valid call - pCFI violation: process[%s | %d] !!!\n",
             p_task->comm,task_pid_nr(p_task));
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> Frame[%d] nr_entries[%d]: [0x%lx]. Full Stack:\n",
             i,p_trace.nr_entries,p_trace.entries[i]);
      printk(KERN_CRIT "--- . ---\n");
      print_stack_trace(&p_trace, 0);
      printk(KERN_CRIT "--- END ---\n");
      p_ed_kill_task_by_task(p_task);
   }

   local_irq_restore(p_flags);

   p_ed_pcfi_free(p_trace.entries);

p_ed_enforce_pcfi_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_enforce_pcfi> (return => %d)\n",p_not_valid);

   return p_not_valid;
}

int p_ed_pcfi_validate_sp(struct task_struct *p_task, struct p_ed_process *p_orig, unsigned long p_sp) {

   unsigned long p_stack = (p_orig) ? (unsigned long) p_orig->p_ed_task.p_stack : 0x0;
   char p_not_valid = 0x0;
   register unsigned long p_stack_offset;

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_ed_enforce_pcfi>\n");

   /*
    * Validate alignment - this test should be passed even we have glitching problem
    */
   if (unlikely((p_sp & ~(THREAD_SIZE - 1)) < (THREAD_SIZE / 16))) {
      p_print_log(P_LKRG_CRIT,
             "<Exploit Detection> process [%s | %d] has invalidly aligned stack pointer! [base:0x%lx c:0x%lx]\n",
             p_task->comm,task_pid_nr(p_task),p_stack,p_sp);
      p_not_valid = 1;
   }

   if (p_stack) {

      if (p_task != p_orig->p_ed_task.p_task) {
         p_print_log(P_LKRG_WARN,
                "<Exploit Detection> [pCFI - SP] Potential kretprobe glitch detected for "
                "process[0x%p | %d | %s] vs orig[0x%p | %d | %s]\n",
                p_task,
                task_pid_nr(p_task),
                p_task->comm,
                p_orig->p_ed_task.p_task,
                p_orig->p_ed_task.p_pid,
                p_orig->p_ed_task.p_comm);
         goto p_ed_pcfi_validate_sp_out;
      }

      /*
       * Validate stack base
       */
      if (unlikely((p_sp & ~(THREAD_SIZE - 1)) != (p_stack & ~(THREAD_SIZE - 1)))) {
         p_print_log(P_LKRG_CRIT,
                "<Exploit Detection> process [%s | %d] has invalid base for stack pointer! [base:0x%lx c:0x%lx]\n",
                p_task->comm,task_pid_nr(p_task),p_stack,p_sp);
         p_not_valid = 1;
      }

      /*
       * Validate if stack is comming from the valid range (CONFIG_VMAP_STACK)
       */

      // TODO

      /*
       * Validate current size of the stack.
       */

      p_stack_offset = p_sp - p_stack;
      if (unlikely(p_stack_offset >= THREAD_SIZE)) {
         p_print_log(P_LKRG_CRIT,
                "<Exploit Detection> process [%s | %d] has invalid stack pointer (stack size mismatch)! [base:0x%lx c:0x%lx diff:0x%lx]\n",
                p_task->comm,task_pid_nr(p_task),p_stack,p_sp,p_stack_offset);
         p_not_valid = 1;
      }
   }

p_ed_pcfi_validate_sp_out:

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_ed_enforce_pcfi> (return => %d)\n",p_not_valid);

   return p_not_valid;
}


int p_exploit_detection_init(void) {

   int p_ret = P_LKRG_SUCCESS;
   unsigned int p_cnt, p_cnt2;
   unsigned int p_umh_global_cnt = sizeof(p_umh_global) / sizeof(p_umh_global[0]);


// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_exploit_detection_init>\n");

   p_print_log(P_LKRG_WARN,
          "Verifying %u potential UMH paths for whitelisting...\n", p_umh_global_cnt);

   for (p_cnt = p_cnt2 = 0; p_cnt < p_umh_global_cnt; p_cnt++) {
      if (!p_check_if_file_exists(p_umh_global[p_cnt].p_path)) {
         p_umh_global[p_cnt].p_enabled = 0x1;
         p_print_log(P_LKRG_INFO,
                "Whitelisting: [%s]\n",p_umh_global[p_cnt].p_path);
         p_cnt2++;
      }
   }
   p_print_log(P_LKRG_WARN,
          "%u UMH paths were whitelisted...\n", p_cnt2);

   p_global_off_cookie = (unsigned long)get_random_long();
   p_global_cnt_cookie = (unsigned long)get_random_long();

   p_global_off_cookie |= P_NORMALIZE_LONG;
   p_global_cnt_cookie |= P_NORMALIZE_LONG;
   p_global_cnt_cookie &= P_MASK_COUNTER;

   if (p_ed_pcfi_cache_init()) {
      p_print_log(P_LKRG_CRIT,
             "Can't initialize ED CFI cache :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }

   if (p_ed_wq_valid_cache_init()) {
      p_print_log(P_LKRG_CRIT,
             "Can't initialize ED WQ cache :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }

   p_is_kernel_text_address = (int (*)(unsigned long))p_kallsyms_lookup_name("__kernel_text_address");

   if (!p_is_kernel_text_address) {
      p_print_log(P_LKRG_ERR,
             "[ED] ERROR: Can't find '__kernel_text_address' function :( Exiting...\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }

   p_freeze_processes = (int (*)(void))p_kallsyms_lookup_name("freeze_processes");

   if (!p_freeze_processes) {
      p_print_log(P_LKRG_ERR,
             "[ED] ERROR: Can't find 'freeze_processes' function :( Exiting...\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }

   p_thaw_processes = (void (*)(void))p_kallsyms_lookup_name("thaw_processes");

   if (!p_thaw_processes) {
      p_print_log(P_LKRG_ERR,
             "[ED] ERROR: Can't find 'thaw_processes' function :( Exiting...\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }

#ifdef CONFIG_SECURITY_SELINUX
   p_selinux_enabled    = (int *)p_kallsyms_lookup_name("selinux_enabled");
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
   p_selinux_state      = (struct p_selinux_state *)p_kallsyms_lookup_name("selinux_state");

   if (!p_selinux_state) {
      p_print_log(P_LKRG_ERR,
             "[ED] ERROR: Can't find 'selinux_state' variable :( Exiting...\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }
 #else
   p_selinux_enforcing  = (int *)p_kallsyms_lookup_name("selinux_enforcing");

   if (!p_selinux_enforcing) {
      p_print_log(P_LKRG_ERR,
             "[ED] ERROR: Can't find 'selinux_enforcing' variable :( Exiting...\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }
 #endif
#endif

   if (!p_selinux_enabled) {
      p_print_log(P_LKRG_ERR,
             "[ED] ERROR: Can't find 'selinux_enabled' variable :( Exiting...\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }
#endif

   if (p_init_rb_ed_pids()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't initialize ED pids cache and red-black tree :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_out;
   }

   // Freeze all non-kernel processes
   while (p_freeze_processes())
      schedule();

   // Dump processes and threads
   p_iterate_processes(p_dump_task_f);

#ifdef CONFIG_SECURITY_SELINUX
   // SELinux information
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
   p_ed_guard_globals.p_selinux.p_selinux_state.enforcing = p_selinux_state->enforcing;
 #else
   p_ed_guard_globals.p_selinux.p_selinux_enforcing = *p_selinux_enforcing;
 #endif
#endif
   p_ed_guard_globals.p_selinux.p_selinux_enabled = *p_selinux_enabled;
   mutex_init(&p_ed_guard_globals.p_selinux_lock);
#endif

   if (p_install_sys_execve_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook execve syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
   if (p_install_sys_execveat_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook execveat syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }
#endif

   if (p_install_call_usermodehelper_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook call_usermodehelper function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_call_usermodehelper_exec_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook call_usermodehelper_exec function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_do_fork_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook fork syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_do_exit_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook exit syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setreuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setreuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setresuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setresuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setfsuid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setfsuid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setgid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setgid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setregid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setregid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setresgid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setresgid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_setfsgid_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setfsgid syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_set_current_groups_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook setgroups syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_do_init_module_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook do_init_module function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
   if (p_install_sys_finit_module_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook finit_module syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }
#endif

   if (p_install_sys_delete_module_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook delete_module syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_generic_permission_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook generic_permission function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

#ifdef CONFIG_SECURITY_SELINUX
   if (p_install_sel_write_enforce_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook sel_write_enforce function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }
#endif

   if (p_install_seccomp_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook seccomp function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_unshare_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook unshare syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

#ifdef CONFIG_USER_NS
   if (p_install_userns_install_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook userns_install function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }
#endif

   /* Caps */
   if (p_install_sys_capset_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook capset syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_cap_task_prctl_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook cap_task_prctl function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   /* Keyring */
   if (p_install_key_change_session_keyring_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook key_change_session_keyring function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_add_key_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook add_key syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_request_key_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook request_key syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_keyctl_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook keyctl syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_sys_ptrace_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook ptrace syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

#ifdef CONFIG_COMPAT

   if (p_install_compat_sys_execve_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_execve syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
   if (p_install_compat_sys_execveat_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_execveat syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }
#endif

   if (p_install_compat_sys_keyctl_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_keyctl syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_compat_sys_ptrace_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_ptrace syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

#ifdef P_SYSCALL_LAYOUT_4_17
   if (p_install_compat_sys_delete_module_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_delete_module syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_compat_sys_capset_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_capset syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_compat_sys_add_key_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_add_key syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_compat_sys_request_key_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook compat_request_key syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }
#endif

#endif

#ifdef CONFIG_X86_X32
 #ifdef P_SYSCALL_LAYOUT_4_17
   if (p_install_x32_sys_execve_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook __x32_sys_execve syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_x32_sys_execveat_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook __x32_sys_execveat syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_x32_sys_keyctl_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook __x32_sys_keyctl syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_x32_sys_ptrace_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook __x32_sys_ptrace syscall :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }
 #endif
#endif

   if (p_install_override_creds_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook override_creds function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_revert_creds_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook revert_creds function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   /* OverlayFS */
   if (p_install_ovl_create_or_link_hook()) {
      p_print_log(P_LKRG_WARN,
             "ERROR: Can't hook ovl_create_or_link function :(\n");
      /*
       * It is not critical scenario. OverlayFS might not be installed in that system.
       * If OverlayFS is installed, used but not found (unlikely) in worst case,
       * we might have FP. Continue...
       */

//      p_ret = P_LKRG_GENERAL_ERROR;
//      goto p_exploit_detection_init_err;
   }

   /* pCFI */
   if (cpu_has(&cpu_data(smp_processor_id()), X86_FEATURE_SMEP))
      p_global_SMEP = 0x1;

   if (p_install_pcfi_mark_inode_dirty_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook __mark_inode_dirty function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_pcfi_schedule_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook schedule function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_pcfi___queue_work_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook __queue_work function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   if (p_install_pcfi_lookup_fast_hook()) {
      p_print_log(P_LKRG_ERR,
             "ERROR: Can't hook lookup_fast function :(\n");
      p_ret = P_LKRG_GENERAL_ERROR;
      goto p_exploit_detection_init_err;
   }

   goto p_exploit_detection_init_out;

p_exploit_detection_init_err:

   p_exploit_detection_exit();

p_exploit_detection_init_out:

   // Thaw all non-kernel processes
   p_thaw_processes();

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_exploit_detection_init> (p_ret => %d)\n",p_ret);

   return p_ret;
}


void p_exploit_detection_exit(void) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_exploit_detection_exit>\n");

   p_uninstall_sys_execve_hook();
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
   p_uninstall_sys_execveat_hook();
#endif
   p_uninstall_call_usermodehelper_hook();
   p_uninstall_call_usermodehelper_exec_hook();
   p_uninstall_do_fork_hook();
   p_uninstall_do_exit_hook();
   p_uninstall_sys_setuid_hook();
   p_uninstall_sys_setreuid_hook();
   p_uninstall_sys_setresuid_hook();
   p_uninstall_sys_setfsuid_hook();
   p_uninstall_sys_setgid_hook();
   p_uninstall_sys_setregid_hook();
   p_uninstall_sys_setresgid_hook();
   p_uninstall_sys_setfsgid_hook();
   p_uninstall_set_current_groups_hook();
   p_uninstall_do_init_module_hook();
#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
   p_uninstall_sys_finit_module_hook();
#endif
   p_uninstall_sys_delete_module_hook();
   p_uninstall_generic_permission_hook();
#ifdef CONFIG_SECURITY_SELINUX
   p_uninstall_sel_write_enforce_hook();
#endif
   p_uninstall_seccomp_hook();
   p_uninstall_sys_unshare_hook();
#ifdef CONFIG_USER_NS
   p_uninstall_userns_install_hook();
#endif
   /* Caps */
   p_uninstall_sys_capset_hook();
   p_uninstall_cap_task_prctl_hook();
   /* Keyring */
   p_uninstall_key_change_session_keyring_hook();
   p_uninstall_sys_add_key_hook();
   p_uninstall_sys_request_key_hook();
   p_uninstall_sys_keyctl_hook();
   p_uninstall_sys_ptrace_hook();
#ifdef CONFIG_COMPAT
   p_uninstall_compat_sys_execve_hook();
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
   p_uninstall_compat_sys_execveat_hook();
#endif
   p_uninstall_compat_sys_keyctl_hook();
   p_uninstall_compat_sys_ptrace_hook();
#ifdef P_SYSCALL_LAYOUT_4_17
   p_uninstall_compat_sys_delete_module_hook();
   p_uninstall_compat_sys_capset_hook();
   p_uninstall_compat_sys_add_key_hook();
   p_uninstall_compat_sys_request_key_hook();
#endif
#endif

#ifdef CONFIG_X86_X32
 #ifdef P_SYSCALL_LAYOUT_4_17
   p_uninstall_x32_sys_execve_hook();
   p_uninstall_x32_sys_execveat_hook();
   p_uninstall_x32_sys_keyctl_hook();
   p_uninstall_x32_sys_ptrace_hook();
 #endif
#endif
   p_uninstall_override_creds_hook();
   p_uninstall_revert_creds_hook();
   /* OverlayFS */
   p_uninstall_ovl_create_or_link_hook();
   /* CFI */
   p_uninstall_pcfi_mark_inode_dirty_hook();
   p_uninstall_pcfi_schedule_hook();
   p_uninstall_pcfi___queue_work_hook();
   p_uninstall_pcfi_lookup_fast_hook();

   /* Delete cache for ED wq validation */
   p_ed_wq_valid_cache_delete();
   /* Delete cache for ED CFI validation */
   p_ed_pcfi_cache_delete();

   /* Before deleting cache i should clean each entry! */
   p_delete_rb_ed_pids();
   p_print_log(P_LKRG_INFO, "kmem_cache \"p_ed_pids\" destroyed!\n");

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_exploit_detection_exit>\n");
}
